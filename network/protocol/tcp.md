本人从事TCP的socket编程多年，趟过很多坑，对于TCP是“全双工的字节流”这几个字的含义有深刻理解。这几个字，文字虽少，但字字精辟。如果没有深刻理解，编程中可能知其然不知其所以然，难有大作为。“全双工的字节流”详解如下：



 (1) 全双工：意味着，TCP的收发是可以同时进行的。亦即接收的时候可以发送，发送的时候也可以接收，两者互不冲突，可同时进行。

​    而OpenSSL则不同，OpenSSL是单工的，亦即收和发不能同时进行，同一时刻只能其中之一进行，也就意味着，OpenSSL的收和发之间必须要加锁互斥，两者不能同时工作。理解了这一点，就很容易明白，OpenSSL的性能必然是低下的，即使不考虑加密带来的损失，理论上也应比普通的socket性能至少低50%，这一工作原理是很重要的原因。



 (2) 字节：意味着，无论物理层或链路层收到的数据是否为一个个二进制位的数据，在TCP层接收到的数据一定是一个个字节。也就是说，我们在进行socket编程时，只需要考虑接收一个个字节，而不是一个个位的数据。



 (3) 流：意味着，socket的数据无头无尾，就像流水一样，如果从中间任意位置起，你无法知道一个消息包确切的开始或结束位置，除非从TCP的头开始算起。

​        ① 也就是意味着，我们在应用层编程时，必须定义一个应用层的包头，从收到的第一个字节开始，通过该包头能确定一个包的长度，然后根据包的长度，确定一个个包的起止位置。这也就是我们看到所有的TCP的socket编程中，都需要定义一个包头，并在其中可以获得应用层包的总长度的原因。

​       ② 同时也意味着，数据流不是一个个应用层的数据包，对于接收，可能收到的是一个完整的数据包，也可能了收到1/3个数据包，也可能收到4/5个数据包，或者一个完整的数据包，也可能收到1.5个或3.2个数据包，这是不确定的。需要自己在编程中，自己解析确定收到的是否完整的数据包，如果不足，需要继续接收；如果多余，需要分拆成多个包。





​    总之，编写一个基本的勉强能用socket程序其实并不难，一般程序员花一个月的时间都能写出来，但要想写出来的程序实现多条TCP连接、不出现各种异常、CPU该忙时就忙，该空闲时时就空闲、不出现各种卡顿、多条连接间不相互影响、持续稳定通信、性能高等质量要求高的程序并非易事，国内外90%的程序员根本做不到，只是很多程序员或公司管理层不自知，对此技术方面的难度没有一个明确的判断。比如，微软的MSN与腾讯的QQ就是一个很好的例子，当年的MSN采用TCP协议，而QQ采用UDP协议，最后效果上来说，采用TCP通信的MSN的通信效果和用户体验方面明显差，而采用相对简单的UDP通信的QQ的通信效果和用户体验好得多（腾讯在技术线路的选择上成功地避开了难度较高的TCP通信，也是体现了腾讯的成功绝不是偶然的），最终导致微软的MSN退出历史舞台，就连微软这样牛X的公司都上演这样的悲剧，更别说一般的公司，在TCP通信上更是难上加难。


   要做一个专业的socket程序的难度还是非常高的，必须有相当多的积累才可能编出质量过硬的软件。如果大家觉得难度过大，或者时间精力不足以从头开始编码，建议使用第三方的socket封装库来实现，专业的事情留给专业的人来做，站在巨人的肩膀上，质量更有保证，比起招聘一个程序员或团队研究2至3年还不一定能出成果相比，使用第三方socket封装库质量可靠得多。比如waisock就是一个非常优秀的socket封装库，该项目在知名公司的多个大型项目中使用过，经过了反覆的锤炼，稳定可靠，性能卓越，官网是http://waisock.szxunxun.com/ ，大家不妨试试。